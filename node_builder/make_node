#!/usr/bin/env bash
set -Eeuo pipefail
set -x

# -------------------------------------------------------------------------
# todo / roadmap
# - download all external assets before running script, have this script
#   consume things out of a local artifact store (directory)
# - enable ability to build kernel / initramfs / ramroot separately. The kernel
#   and initramfs will need much less iteration than the ramroot, a _lot_ of
#   the build process now is generating the kernel.
# - build my own kernel. Can strip it down, have a better understanding how
#   thing work at that level
# - can this be configured to run without root? I've failed more than one build
#   while the script was waiting for a sudo password.
# - go through all the initramfs-tools and format / cleanup
# - only copy to OUT_DIR once all files are ready
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# This script is a big old mess of spaghetti that somehow builds the worker
# node artifacts. This script is a prime target for refactoring in the future.
# -------------------------------------------------------------------------

# to avoid prepending command with sudo and having the build timeout waiting
# for a password just require that script to be run as root.
if [ "$EUID" -ne 0 ]
  then echo "Please run as root"
  exit
fi

log() {
  echo "==> $*"
}

# -------------------------------------------------------------------------

# Here are some environment variables we can set to change the behavior of the
# build.
DEBUG=${DEBUG:-}
# max compression is good for network transfer speeds, but does take quite a
# bit of time. Its nice to set to 0 while iterating and working locally.
PIXZ_COMPRESSION_LEVEL=${PIXZ_COMPRESSION_LEVEL:-9}


# make a best effort case to clean up after the build has finished.
function cleanup()
{
  # these drives will already be unmounted if everything has gone well so just
  # make sure it doesn't error. I could do some `if mount | grep...` mess, but
  # this seems like an easier way to just get moving.

  if mount | rg "$CHROOT_DIR"; then
    umount "$CHROOT_DIR/proc" "$CHROOT_DIR/sys" || true
  fi


  # do not remove the chroot if we are running a debug build
  [[ -z $DEBUG ]] || rm -rf "$WORK_DIR"
}

trap cleanup EXIT
# Using a work directory under `/tmp` so I can be lazy and not care about
# cleaning up the mount points debootstrap creates if things go awry. I reboot
# my machines pretty frequently so this will resolve itself.
WORK_DIR=$(mktemp -d --tmpdir=/tmp debootstrap.XXXX)
CHROOT_DIR="$WORK_DIR/chroot"

GIT_REF=$(git rev-parse --short HEAD)
# Should this build be marked as dirty?
# todo: in the future: maybe a mark work worker nodes to run dirty builds?
GIT_DIRTY="-dirty"
git diff-index --quiet HEAD -- && GIT_DIRTY=
# can't use ISO-8601 due to `:` in file paths
BUILD_TIMESTAMP=$(date --utc +%Y-%M-%d_%H%M%S)
OUT_DIR="$1/$BUILD_TIMESTAMP-${GIT_REF}${GIT_DIRTY}"
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# I think there is a one liner using parameter expansion, but didn't want to
# fuss with it too much.
DEB_BOOTSTRAP=deb_cache
if [ -z "$CACHE_DIR" ]; then
  DEB_BOOTSTRAP="/tmp/$DEB_BOOTSTRAP"
else
  DEB_BOOTSTRAP="${PWD}/${CACHE_DIR}/$DEB_BOOTSTRAP"
fi

# do this early so if there is a GPG error it fails fast
# todo: could this be passed in a node boot time with an boot arg?
# todo: renable this
# todo: pass in a boot arg?
# ENCRYPT_KEY=${CONSUL_ENCRYPT_KEY:-"$2"}



mkdir --parent "$OUT_DIR" "$DEB_BOOTSTRAP"
# todo: go back to `--varient=minbase` to save more space.
# todo: move from eoan -> focal once docker is supported.

# note: debain wasn't supported on my x86 boards
# todo: once nix's debootstrap package is updated, use focal instead of eoan

debootstrap_packages=(
  # core system package. Without these system will not boot
  locales
  initramfs-tools
  linux-generic # todo: is -generic the right choice?

  # basic dev tools. These tools are available for the sake of installion
  #                  script.
  #software-properties-common
  curl
  openssh-server # it will boot, but I like remote access
  parted
  rsync
  tar

  # debugging / util. These increase size, and are not nessacary to boot or build the image, but are nice to have.
  glances # system monitoring
  htop    # ligherwirght monitoring
  mosh    # better ssh
  neovim  # text editing

  # application specific
  # todo: should thier own scripts handle installing these?
  # gettext-base    # needed for envsubst, in consul install
  # keepalived      # used for poor mans load balanceer
  # nfs-common      # for NFS share, used by traefik

  # these need to be verified that they are required
  # ca-certificates
  # gpg-agent
  # pixz
  # xfsprogs
)

# todo: it would be nice to add the option to reuse an existing debootstap and
#       not just blindly recreate one. While this behavior is nice to ensuring
#       purity, it does take a bit of time.
log "Running debootstrap"
debootstrap \
  --arch=amd64 \
  --components=main,universe \
  --cache-dir="$DEB_BOOTSTRAP" \
  "--include=${debootstrap_packages[*]}" \
  focal \
  "$CHROOT_DIR" \
  http://archive.ubuntu.com/ubuntu/

cp -r "$SCRIPT_DIR"/initramfs-tools/* "$CHROOT_DIR/etc/initramfs-tools/"


run_script_in_chroot() {
  # helper script to run bash scripts within the chroot we just created.

  log " Running '$*'"
  # todo: I am just giving every script my consul encryption key. This is a
  # pretty bad security issues, but I also control all the scripts running, so
  # its not too terrible. I need to work out how to best propagate secrets into
  # all the configuration files.

  # shellcheck disable=SC2024
  # deep breath. Stuff of madness or genious below. The goal here is to be able
  # to write scripts in a normal way, refrencing files alongside or deeper in
  # the file hiarchery. This way I don't need to heredoc every config file
  # inline with a script. However, some of my "scripts" are still just text,
  # hence having to check if this "script" lives under /prod/self/fd.
  #
  # I suppose there is some edge case where I actaully write a script under
  # /prod/self/fd/ and it doesn't work as expeced?

  tmp_script_dir="/tmp/chroot-script"
  script="$1"
  args=( "${@:2}" ) # could be empty
  script_dir=$(dirname "$script")
  module_name=$(basename "$script_dir")
  script_name=$(basename "$script")

  # debug info
  echo "== START SCRIPT INFO =="
  echo "tmp_script_dir: $tmp_script_dir"
  echo "script: $script"
  echo "args: ${args[*]}"
  echo "script_dir: $script_dir"
  echo "module_name: $module_name"
  echo "script_name: $script_name"
  echo "== END SCRIPT INFO =="

  mkdir -p "$CHROOT_DIR/$tmp_script_dir"
  if [[ "$script_dir" == "/dev/fd" ]]; then
    # copy just the text "script"
    module_name="inline"
    mkdir "$CHROOT_DIR/$tmp_script_dir/$module_name"
    cp --dereference "$script" "$CHROOT_DIR/$tmp_script_dir/$module_name/"
  else
    # copy the whole module directory
    cp -r --dereference "$script_dir" "$CHROOT_DIR/$tmp_script_dir/"
  fi

  chroot "$CHROOT_DIR" /usr/bin/env DEBIAN_FRONTEND=noninteractive PATH=/usr/sbin:/usr/bin/:/bin:/sbin:/usr/local/bin bash "$tmp_script_dir/$module_name/$script_name" "${args[@]}"

  rm -r "${CHROOT_DIR:?}/$tmp_script_dir"
}

# todo: enable and make this work
#run_script_in_chroot "$SCRIPT_DIR/modules/glusterfs/install"

#run_script_in_chroot <(echo "
## doing some basic setup
#locale-gen 'en_US.UTF-8'
#update-locale LANG=en_US.UTF-8
#
## this is used so I can fact check what build I am running
#echo \"$(git rev-parse HEAD)\" > /etc/node-build-rev
#echo \"$BUILD_TIMESTAMP\" > /etc/node-build-date
#
## I had an issue where the scripts in '/etc/initramfs-tools/hooks' seemed to be
## silently ignored. It was becuase the scripts were not executbale.
#chmod -R 755 /etc/initramfs-tools/
#
## add ssh key for easier management
## todo: this should be injected in and not hard-coded
#mkdir -p /root/.ssh
#cat << SSH >> /root/.ssh/authorized_keys
#ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDZq6q45h3OVj7Gs4afJKL7mSz/bG+KMG0wIOEH+wXmzDdJ0OX6DLeN7pua5RAB+YFbs7ljbc8AFu3lAzitQ2FNToJC1hnbLKU0PyoYNQpTukXqP1ptUQf5EsbTFmltBwwcR1Bb/nBjAIAgi+Z54hNFZiaTNFmSTmErZe35bikqS314Ej60xw2/5YSsTdqLOTKcPbOxj2kulznM0K/z/EDcTzGqc0Mcnf51NtzxlmB9NR4ppYLoi7x+rVWq04MbdAmZK70p5ndRobqYSWSKq+WDUAt2+CiTm6ItDowTLuo3zjHyYV1eCnB35DdakKVldIHrQyhmhbf5hJi6Ywx6XCzlFoNpkl/++RrJT2rf0XpGdlRoLQoKFvNRfnO4LI499SIfFb9Pwq7LhF1C1kTmshN/9S44d6VCCYXLE4uS8OPv7IXxUvFQZaIKCbomd2FzXxUwf4lg2gSlczysgDaVsMAUvlfDVgTFX8Xt1LFl3DqNtUiUpa9+Jnst/jCqqOBf3e8= kyle@alpha
#SSH
#")
#
## make sure we are running the latest security updates
## todo: this doesn't work
##run_script_in_chroot <(echo "
##apt-get -q update
##apt-get -yq dist-upgrade
##")
#
#run_script_in_chroot "$SCRIPT_DIR/modules/consul_agent/install" "$ENCRYPT_KEY"
#run_script_in_chroot "$SCRIPT_DIR/modules/nomad_agent/install"
#run_script_in_chroot "$SCRIPT_DIR/modules/scheduled_reboot/install"
#
## todo: install this the real way
#run_script_in_chroot <(echo "
#curl -fsSL https://get.docker.com | sh
#")
#
## keep alive lets me have a floating IP between all worker nodes
#run_script_in_chroot "$SCRIPT_DIR/modules/keepalived/install"
#
## I install traefik as a system service so I can easily bind to the floating IP. Initally I tried to run this under nomad for the flexibility, but had trouble getting nomad to work correctly with a floating IP.
#run_script_in_chroot "$SCRIPT_DIR/modules/traefik/install"

# doing some last housekeeping and cleanup
run_script_in_chroot <(echo "
echo 'root:root' | chpasswd # todo: pull from password manager
echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config

# this is what builds the updated initrd to network boot with. It will run the
# scripts in /etc/initramfs-tools.
update-initramfs -cu
")
#
## setup mount points
#cp "$SCRIPT_DIR/../files/format-scratch.service"  "$CHROOT_DIR/etc/systemd/system/"
#cp "$SCRIPT_DIR/../files/scratch-local.mount"     "$CHROOT_DIR/etc/systemd/system/"
#cp "$SCRIPT_DIR/../files/mnt-nfs.mount"           "$CHROOT_DIR/etc/systemd/system/"
#run_script_in_chroot <(echo "
#systemctl enable format-scratch
#systemctl enable scratch-local.mount
#systemctl enable mnt-nfs.mount
#")

umount "$CHROOT_DIR/proc" "$CHROOT_DIR/sys"

# future: this can be split into two separate process to generate the
# kerne;/initramfs and the process to create the rootramfs. This would allow
# easier updating on one or the other. For now, simplicity wins.
# todo: symlink these?
# todo: which versions do I really need?
cp --dereference "$CHROOT_DIR"/boot/vmlinuz-* "$OUT_DIR/"
ln -rs "$OUT_DIR/vmlinuz"* "$OUT_DIR/vmlinuz"

cp --dereference "$CHROOT_DIR"/boot/initrd.img-* "$OUT_DIR/"
ln -rs "$OUT_DIR/initrd.img-"* "$OUT_DIR/initrd.img"

# now that we have generated the initrd and kerenl, we can remove files that
# are not needed within the ramFS.
rm -fr "$CHROOT_DIR/tmp/*"
rm -fr "$CHROOT_DIR/var/cache" # is this safe?
rm "$CHROOT_DIR"/boot/vmlinuz-*
rm "$CHROOT_DIR"/boot/initrd.img-*

# now getting risky...
# These modules aren't used on my board, but I should comment these out if I
# seem to be having weird runtime issues.
rm -fr "$CHROOT_DIR"/usr/lib/firmware/netronome
rm -fr "$CHROOT_DIR"/usr/lib/firmware/liquidio
rm -fr "$CHROOT_DIR"/usr/lib/firmware/amdgpu
rm -fr "$CHROOT_DIR"/usr/lib/modules/5.3.0-18-generic/kernel/drivers/net/wireless

pushd "$CHROOT_DIR" > /dev/null && {
  # todo: I feel like there should be an easier way to do this.
  tar -cf "$WORK_DIR/ramroot.tar" .
}
popd > /dev/null

# This can take a while. Write to a temp file before copying it over to the
# outfolder so its not in an intermediate state for too long.
pixz "-$PIXZ_COMPRESSION_LEVEL" < "$WORK_DIR/ramroot.tar" > "$WORK_DIR/ramroot.tar.xz"



cp "$WORK_DIR/ramroot.tar.xz" "$OUT_DIR/ramroot.tar.xz"

# set the permissions on the artifacts so they can be consumed by a normal user.
chown "$(whoami)" "$OUT_DIR"
chmod -R 755 "$OUT_DIR"
