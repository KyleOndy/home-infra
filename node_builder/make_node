#!/usr/bin/env bash
set -Eeuo pipefail

# -------------------------------------------------------------------------
# todo / roadmap
# - download all external assets before running script, have this script
#   consume things out of a local artifact store (directory)
# - enable ability to build kernel / initramfs / ramroot separately. The kernel
#   and initramfs will need much less iteration than the ramroot, a _lot_ of
#   the build process now is generating the kernel.
# - build my own kernel. Can strip it down, have a better understanding how
#   thing work at that level
# - can this be configured to run without root? I've failed more than one build
#   while the script was waiting for a sudo password.
# - go through all the initramfs-tools and format / cleanup
# - only copy to OUT_DIR once all files are ready
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# This script is a big old mess of spaghetti that somehow builds the worker
# node artifacts. This script is a prime target for refactoring in the future.
# -------------------------------------------------------------------------

build_kernel() {
  echo "--kernel is not yet supported. Kernel is currently built as part of initramfs building."
  exit 1
}

build_initramfs() {
  # keeping this naive for now, just reproducing the logic being used in the
  # prior monolith approach.

  # trying to use some variation of `chroot --variant=fakechroot ...`,
  # `fakechroot`, and `fakeroot` was leading me down a dark hole, PATH errors
  # and GLIBC errors. Both I think related to NixOS toself. I'd like to revisit
  # it at some point, but just using sudo for now to keep things simple and
  # keep moving forward.
  WORK_DIR="$(mktemp --directory --tmpdir=/tmp initramfs.XXXX)"

  packages=(
    initramfs-tools
    linux-generic # todo: is -generic the right choice?
    locales
    openssh-server
    pixz # need by ramroot script
    tar # need by ramroot script
  )

  debootstrap \
  --arch=amd64 \
  --components=main,universe \
  --cache-dir="$DEB_BOOTSTRAP" \
  --include="${packages[*]}" \
  focal \
  "$WORK_DIR" \
  http://archive.ubuntu.com/ubuntu/

  cp -r "$SCRIPT_DIR"/initramfs-tools/* "$WORK_DIR/etc/initramfs-tools/"
  # Implement insecurity
  run_script_in_chroot "${WORK_DIR}" "
  locale-gen 'en_US.UTF-8'
  update-locale LANG=en_US.UTF-8

  # this is used so I can fact check what build I am running
  echo \"$(git rev-parse HEAD)\" > /etc/node-build-rev
  echo \"$BUILD_TIMESTAMP\" > /etc/node-build-date
  passwd -d root # remove password on root account

  ls -laxo /etc/initramfs-tools/
  update-initramfs -cu
  "

  # todo: add my ssh key
  sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/' "${WORK_DIR}/etc/ssh/sshd_config"
  sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/' "${WORK_DIR}/etc/ssh/sshd_config"

  cp -p --dereference "${WORK_DIR}/boot"/vmlinuz-*    "${OUT_DIR}/vmlinuz"
  cp -p --dereference "${WORK_DIR}/boot"/initrd.img-* "${OUT_DIR}/initramfs"
  chown kyle "${OUT_DIR}/vmlinuz" "${OUT_DIR}/initramfs"
  chmod 755 "${OUT_DIR}/vmlinuz" "${OUT_DIR}/initramfs"
}

build_ramroot() {
  WORK_DIR="$(mktemp --directory --tmpdir=/tmp ramroot.XXXX)"
  date > "${WORK_DIR}/hello.txt"
  tar --sort=name -cf "$WORK_DIR/ramroot.tar" "${WORK_DIR}"
  pixz "-$PIXZ_COMPRESSION_LEVEL" < "$WORK_DIR/ramroot.tar" > "$WORK_DIR/ramroot.tar.xz"
  cp -p "${WORK_DIR}/ramroot.tar.xz" "${OUT_DIR}/ramroot.tar.xz"
  chown kyle "${OUT_DIR}/ramroot.tar.xz"
  chmod 755 "${OUT_DIR}/ramroot.tar.xz"
}

run_script_in_chroot() {
  # helper script to run bash scripts within the chroot we just created.
  log " Running '$*'"
  # todo: I am just giving every script my consul encryption key. This is a
  # pretty bad security issues, but I also control all the scripts running, so
  # its not too terrible. I need to work out how to best propagate secrets into
  # all the configuration files.

  # shellcheck disable=SC2024
  # deep breath. Stuff of madness or genious below. The goal here is to be able
  # to write scripts in a normal way, refrencing files alongside or deeper in
  # the file hiarchery. This way I don't need to heredoc every config file
  # inline with a script. However, some of my "scripts" are still just text,
  # hence having to check if this "script" lives under /prod/self/fd.
  #
  # I suppose there is some edge case where I actaully write a script under
  # /prod/self/fd/ and it doesn't work as expeced?

  # either a file (script) is being passed in, or its an inline script. If its
  # a file, there may be arguments along with it
  #if [[ -f "$script" ]]; then
  #  true
  #else
  #  tmp=$(mktemp)
  #  echo "$script" > "$tmp"
  #  script=$tmp
  #fi

  #chroot "$CHROOT_DIR" /usr/bin/env DEBIAN_FRONTEND=noninteractive PATH=/usr/sbin:/usr/bin/:/bin:/sbin:/usr/local/bin bash "$script" "${args[@]}"


  CHROOT_DIR=$1
  script="$2"
  args=( "${@:3}" ) # could be empty
  tmp_script_dir="tmp/chroot-script"

  # debug info
  #echo "== START SCRIPT INFO =="
  #echo "tmp_script_dir: $tmp_script_dir"
  #echo "script: $script"
  #echo "args: ${args[*]}"
  #echo "script_dir: $script_dir"
  #echo "module_name: $module_name"
  #echo "script_name: $script_name"
  #echo -e "script_contents:\n$(cat "$script")"
  #echo "== END SCRIPT INFO =="

  mkdir -p "$CHROOT_DIR/$tmp_script_dir"


  if [[ -f "$script" ]]; then
    # copy the whole module directory
    script_dir=$(dirname "$script")
    module_name=$(basename "$script_dir")
    script_name=$(basename "$script")
    cp -r --dereference "$script_dir" "$CHROOT_DIR/$tmp_script_dir/"
  else
    module_name="inline"
    script_name=$$
    sp="${CHROOT_DIR}/${tmp_script_dir}/${module_name}"
    mkdir -p "$sp"
    echo "$script" > "${sp}/${script_name}"
  fi

  chroot "$CHROOT_DIR" /usr/bin/env DEBIAN_FRONTEND=noninteractive PATH=/usr/sbin:/usr/bin/:/bin:/sbin:/usr/local/bin bash "/${tmp_script_dir}/${module_name}/${script_name}" "${args[@]}"

  rm -r "${CHROOT_DIR:?}/$tmp_script_dir"
}

log() {
  echo "==> $*"
}

BUILD_KERNEL=false
BUILD_INITRAMFS=false
BUILD_RAMROOM=false

while (( "$#" )); do
  case "$1" in
    -k|--kernel)
      BUILD_KERNEL=true
      shift
      ;;
    -i|--initramfs)
      BUILD_INITRAMFS=true
      shift
      ;;
    -r|--ramroot)
      BUILD_RAMROOM=true
      shift
      ;;
    *) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
  esac
done


# -------------------------------------------------------------------------

# to avoid prepending command with sudo and having the build timeout waiting
# for a password just require that script to be run as root.
if [ "$EUID" -ne 0 ]
  then echo "Please run as root"
  exit
fi

# -------------------------------------------------------------------------

# Here are some environment variables we can set to change the behavior of the
# build.
DEBUG=${DEBUG:-}
# max compression is good for network transfer speeds, but does take quite a
# bit of time. Its nice to set to 0 while iterating and working locally.
PIXZ_COMPRESSION_LEVEL=${PIXZ_COMPRESSION_LEVEL:-9}


# make a best effort case to clean up after the build has finished.
function cleanup()
{
  # these drives will already be unmounted if everything has gone well so just
  # make sure it doesn't error. I could do some `if mount | grep...` mess, but
  # this seems like an easier way to just get moving.

  if mount | rg "$CHROOT_DIR"; then
    umount "$CHROOT_DIR/proc" "$CHROOT_DIR/sys" || true
  fi


  # do not remove the chroot if we are running a debug build
  #[[ -z $DEBUG ]] || rm -rf "$WORK_DIR"
}

trap cleanup EXIT
# Using a work directory under `/tmp` so I can be lazy and not care about
# cleaning up the mount points debootstrap creates if things go awry. I reboot
# my machines pretty frequently so this will resolve itself.
WORK_DIR=$(mktemp -d --tmpdir=/tmp debootstrap.XXXX)
CHROOT_DIR="$WORK_DIR/chroot"

GIT_REF=$(git rev-parse --short HEAD)
# Should this build be marked as dirty?
# todo: in the future: maybe a mark work worker nodes to run dirty builds?
GIT_DIRTY="-dirty"
git diff-index --quiet HEAD -- && GIT_DIRTY=
# can't use ISO-8601 due to `:` in file paths
BUILD_TIMESTAMP=$(date --utc +%Y-%m-%d_%H%M%S)

DIST=${DIST:-dist}
OUT_DIR="$DIST/$BUILD_TIMESTAMP-${GIT_REF}${GIT_DIRTY}"

# I think there is a one liner using parameter expansion, but didn't want to
# fuss with it too much.
DEB_BOOTSTRAP=deb_cache
if [ -z "$CACHE_DIR" ]; then
  DEB_BOOTSTRAP="/tmp/$DEB_BOOTSTRAP"
else
  DEB_BOOTSTRAP="${PWD}/${CACHE_DIR}/$DEB_BOOTSTRAP"
fi
mkdir --parent "$OUT_DIR" "$DEB_BOOTSTRAP"

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"



$BUILD_KERNEL    && build_kernel
$BUILD_INITRAMFS && build_initramfs
$BUILD_RAMROOM   && build_ramroot
