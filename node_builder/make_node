#!/usr/bin/env bash
set -Eeuo pipefail

# -------------------------------------------------------------------------
# todo / roadmap
# - download all external assets before running script, have this script
#   consume things out of a local artifact store (directory)
# - enable ability to build kernel / initramfs / ramroot separately. The kernel
#   and initramfs will need much less iteration than the ramroot, a _lot_ of
#   the build process now is generating the kernel.
# - build my own kernel. Can strip it down, have a better understanding how
#   thing work at that level
# - can this be configured to run without root? I've failed more than one build
#   while the script was waiting for a sudo password.
# - go through all the initramfs-tools and format / cleanup
# - only copy to OUT_DIR once all files are ready
# - update component verisons
#   - nomad
#   - consul
#   - traefik
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# This script is a big old mess of spaghetti that somehow builds the worker
# node artifacts. This script is a prime target for refactoring in the future.
# -------------------------------------------------------------------------

build_kernel() {
  echo "--kernel is not yet supported. Kernel is currently built as part of initramfs building."
  exit 1
}

build_initramfs() {
  # keeping this naive for now, just reproducing the logic being used in the
  # prior monolith approach.

  # trying to use some variation of `chroot --variant=fakechroot ...`,
  # `fakechroot`, and `fakeroot` was leading me down a dark hole, PATH errors
  # and GLIBC errors. Both I think related to NixOS toself. I'd like to revisit
  # it at some point, but just using sudo for now to keep things simple and
  # keep moving forward.
  WORK_DIR="$(mktemp --directory --tmpdir=/tmp initramfs.XXXX)"

  packages=(
    initramfs-tools
    linux-generic # todo: is -generic the right choice?
    locales
    openssh-server
    pixz # need by ramroot script
    tar # need by ramroot script
  )

  # todo: variant=minibase?
  debootstrap \
  --arch=amd64 \
  --components=main,universe \
  --cache-dir="$DEB_BOOTSTRAP" \
  --include="${packages[*]}" \
  focal \
  "$WORK_DIR" \
  http://archive.ubuntu.com/ubuntu/

  mount --bind /dev/pts "${WORK_DIR}/dev/pts"

  cp -r "$SCRIPT_DIR"/initramfs-tools/* "$WORK_DIR/etc/initramfs-tools/"
  # Implement insecurity
  run_script_in_chroot "${WORK_DIR}" "
  locale-gen 'en_US.UTF-8'
  update-locale LANG=en_US.UTF-8

  # this is used so I can fact check what build I am running
  echo \"$(git rev-parse HEAD)\" > /etc/node-build-rev
  echo \"$BUILD_TIMESTAMP\" > /etc/node-build-date
  passwd -d root # remove password on root account

  # for docker
  echo overlay      >> /etc/initramfs-tools/modules
  echo br_netfilter >> /etc/initramfs-tools/modules

  update-initramfs -cu
  "

  # todo: add my ssh key
  sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/' "${WORK_DIR}/etc/ssh/sshd_config"
  sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/' "${WORK_DIR}/etc/ssh/sshd_config"

  cp -p --dereference "${WORK_DIR}/boot"/vmlinuz-*    "${OUT_DIR}/vmlinuz"
  ls -laxoh "${WORK_DIR}/boot/"
  cp -p --dereference "${WORK_DIR}/boot"/initrd.img-* "${OUT_DIR}/initramfs"
  chmod 755 "${OUT_DIR}/vmlinuz" "${OUT_DIR}/initramfs"
  chown kyle -R "${OUT_DIR}"
  umount "$WORK_DIR/proc" "$WORK_DIR/sys" "$WORK_DIR/dev/pts"
  rm -r "${WORK_DIR}"
}

build_ramroot() {
  WORK_DIR="$(mktemp --directory --tmpdir=/tmp ramroot.XXXX)"

  packages=(
    ca-certificates
    curl
    gettext-base    # needed for envsubst, in consul install
    glances # system monitoring
    gpg-agent
    htop    # ligherwirght monitoring
    locales
    mosh    # better ssh
    neovim  # text editing
    openssh-server
    pixz
    pixz # need by ramroot script
    tar # need by ramroot script
    unzip
    xfsprogs
  )
  debootstrap \
  --arch=amd64 \
  --components=main,universe \
  --cache-dir="$DEB_BOOTSTRAP" \
  --include="${packages[*]}" \
  focal \
  "$WORK_DIR" \
  http://archive.ubuntu.com/ubuntu/

  mount --bind /dev/pts "${WORK_DIR}/dev/pts"

  # book keeping
  run_script_in_chroot "${WORK_DIR}" "
  locale-gen 'en_US.UTF-8'
  update-locale LANG=en_US.UTF-8
  echo \"$(git rev-parse HEAD)\" > /etc/node-build-rev
  echo \"$BUILD_TIMESTAMP\" > /etc/node-build-date
  "

  # ssh
  run_script_in_chroot "$WORK_DIR" "
  # add ssh key for easier management
  # todo: this should be injected in and not hard-coded

  passwd -d root # remove password on root account
  mkdir -p /root/.ssh
  cat << SSH >> /root/.ssh/authorized_keys
  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDZq6q45h3OVj7Gs4afJKL7mSz/bG+KMG0wIOEH+wXmzDdJ0OX6DLeN7pua5RAB+YFbs7ljbc8AFu3lAzitQ2FNToJC1hnbLKU0PyoYNQpTukXqP1ptUQf5EsbTFmltBwwcR1Bb/nBjAIAgi+Z54hNFZiaTNFmSTmErZe35bikqS314Ej60xw2/5YSsTdqLOTKcPbOxj2kulznM0K/z/EDcTzGqc0Mcnf51NtzxlmB9NR4ppYLoi7x+rVWq04MbdAmZK70p5ndRobqYSWSKq+WDUAt2+CiTm6ItDowTLuo3zjHyYV1eCnB35DdakKVldIHrQyhmhbf5hJi6Ywx6XCzlFoNpkl/++RrJT2rf0XpGdlRoLQoKFvNRfnO4LI499SIfFb9Pwq7LhF1C1kTmshN/9S44d6VCCYXLE4uS8OPv7IXxUvFQZaIKCbomd2FzXxUwf4lg2gSlczysgDaVsMAUvlfDVgTFX8Xt1LFl3DqNtUiUpa9+Jnst/jCqqOBf3e8= kyle@alpha
SSH
  "

  # todo: unattended security upgrades
  # make sure we are running the latest security updates
  # todo: this doesn't work
  run_script_in_chroot "$WORK_DIR" "
  apt-get -qq update
  apt-get -qq dist-upgrade
  "

  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/glusterfs/install"

  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/consul_agent/install" "todo_consul_key"
  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/nomad_agent/install"
  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/scheduled_reboot/install"

  # todo: install this the real way
  run_script_in_chroot "$WORK_DIR" "curl -fsSL https://get.docker.com | sh"

  # keep alive lets me have a floating IP between all worker nodes
  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/keepalived/install"

  # I install traefik as a system service so I can easily bind to the floating IP. Initally I tried to run this under nomad for the flexibility, but had trouble getting nomad to work correctly with a floating IP.
  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/traefik/install"

  run_script_in_chroot "$WORK_DIR" "$SCRIPT_DIR/modules/mounts/install"


  # ------------------
  # Done with chroot
  # ------------------

  umount "$WORK_DIR/proc" "$WORK_DIR/sys" "$WORK_DIR/dev/pts"
  tmp=$(mktemp -d)
  pushd "$WORK_DIR" && {
    tar --sort=name -cf "$tmp/ramroot.tar" .
  } && popd
  pixz "-$PIXZ_COMPRESSION_LEVEL" < "${tmp}/ramroot.tar" > "${tmp}/ramroot.tar.xz"
  cp -p "${tmp}/ramroot.tar.xz" "${OUT_DIR}/ramroot.tar.xz"
  chmod 755 "${OUT_DIR}/ramroot.tar.xz"
  chown kyle -R "${OUT_DIR}"
  rm -r "${WORK_DIR}"
}

run_script_in_chroot() {
  # helper script to run bash scripts within the chroot we just created.
  #log " Running '$*'"
  # todo: I am just giving every script my consul encryption key. This is a
  # pretty bad security issues, but I also control all the scripts running, so
  # its not too terrible. I need to work out how to best propagate secrets into
  # all the configuration files.

  # shellcheck disable=SC2024
  # deep breath. Stuff of madness or genious below. The goal here is to be able
  # to write scripts in a normal way, refrencing files alongside or deeper in
  # the file hiarchery. This way I don't need to heredoc every config file
  # inline with a script. However, some of my "scripts" are still just text,
  # hence having to check if this "script" lives under /prod/self/fd.
  #
  # I suppose there is some edge case where I actaully write a script under
  # /prod/self/fd/ and it doesn't work as expeced?

  # either a file (script) is being passed in, or its an inline script. If its
  # a file, there may be arguments along with it
  #if [[ -f "$script" ]]; then
  #  true
  #else
  #  tmp=$(mktemp)
  #  echo "$script" > "$tmp"
  #  script=$tmp
  #fi

  #chroot "$CHROOT_DIR" /usr/bin/env DEBIAN_FRONTEND=noninteractive PATH=/usr/sbin:/usr/bin/:/bin:/sbin:/usr/local/bin bash "$script" "${args[@]}"


  CHROOT_DIR=$1
  script="$2"
  args=( "${@:3}" ) # could be empty
  tmp_script_dir="tmp/chroot-script"

  # debug info
  #echo "== START SCRIPT INFO =="
  #echo "tmp_script_dir: $tmp_script_dir"
  #echo "script: $script"
  #echo "args: ${args[*]}"
  #echo "script_dir: $script_dir"
  #echo "module_name: $module_name"
  #echo "script_name: $script_name"
  #echo -e "script_contents:\n$(cat "$script")"
  #echo "== END SCRIPT INFO =="

  mkdir -p "$CHROOT_DIR/$tmp_script_dir"


  if [[ -f "$script" ]]; then
    # copy the whole module directory
    script_dir=$(dirname "$script")
    module_name=$(basename "$script_dir")
    script_name=$(basename "$script")
    cp -r --dereference "$script_dir" "$CHROOT_DIR/$tmp_script_dir/"
  else
    module_name="inline"
    script_name=$$
    sp="${CHROOT_DIR}/${tmp_script_dir}/${module_name}"
    mkdir -p "$sp"
    echo "$script" > "${sp}/${script_name}"
  fi

  chroot "$CHROOT_DIR" /usr/bin/env DEBIAN_FRONTEND=noninteractive PATH=/usr/sbin:/usr/bin/:/bin:/sbin:/usr/local/bin bash "/${tmp_script_dir}/${module_name}/${script_name}" "${args[@]}"

  rm -r "${CHROOT_DIR:?}/$tmp_script_dir"
}

log() {
  echo "==> $*"
}

BUILD_KERNEL=false
BUILD_INITRAMFS=false
BUILD_RAMROOT=false

while (( "$#" )); do
  case "$1" in
    -k|--kernel)
      BUILD_KERNEL=true
      shift
      ;;
    -i|--initramfs)
      BUILD_INITRAMFS=true
      shift
      ;;
    -r|--ramroot)
      BUILD_RAMROOM=true
      shift
      ;;
    *) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
  esac
done


# -------------------------------------------------------------------------

# to avoid prepending command with sudo and having the build timeout waiting
# for a password just require that script to be run as root.
if [ "$EUID" -ne 0 ]
  then echo "Please run as root"
  exit
fi

# -------------------------------------------------------------------------

# Here are some environment variables we can set to change the behavior of the
# build.
DEBUG=${DEBUG:-}
# max compression is good for network transfer speeds, but does take quite a
# bit of time. Its nice to set to 0 while iterating and working locally.
PIXZ_COMPRESSION_LEVEL=${PIXZ_COMPRESSION_LEVEL:-9}


# make a best effort case to clean up after the build has finished.
#function cleanup()
#{
#  # these drives will already be unmounted if everything has gone well so just
#  # make sure it doesn't error. I could do some `if mount | grep...` mess, but
#  # this seems like an easier way to just get moving.
#
#  if mount | rg "$CHROOT_DIR"; then
#    umount "$CHROOT_DIR/proc" "$CHROOT_DIR/sys" || true
#  fi
#}
#
#trap cleanup EXIT
# Using a work directory under `/tmp` so I can be lazy and not care about
# cleaning up the mount points debootstrap creates if things go awry. I reboot
# my machines pretty frequently so this will resolve itself.
WORK_DIR=$(mktemp -d --tmpdir=/tmp debootstrap.XXXX)
CHROOT_DIR="$WORK_DIR/chroot"

GIT_REF=$(git rev-parse --short HEAD)
# Should this build be marked as dirty?
# todo: in the future: maybe a mark work worker nodes to run dirty builds?
GIT_CHANGES="+changes"
git diff-index --quiet HEAD -- && GIT_CHANGES=
# can't use ISO-8601 due to `:` in file paths
BUILD_TIMESTAMP=$(date --utc +%Y-%m-%d_%H%M%S)

DIST=${DIST:-dist}
OUT_DIR="$DIST/$BUILD_TIMESTAMP-${GIT_REF}${GIT_CHANGES}"

# I think there is a one liner using parameter expansion, but didn't want to
# fuss with it too much.
DEB_BOOTSTRAP=deb_cache
if [ -z "$CACHE_DIR" ]; then
  DEB_BOOTSTRAP="/tmp/$DEB_BOOTSTRAP"
else
  DEB_BOOTSTRAP="${PWD}/${CACHE_DIR}/$DEB_BOOTSTRAP"
fi
mkdir --parent "$OUT_DIR" "$DEB_BOOTSTRAP"

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"



$BUILD_KERNEL    && build_kernel
$BUILD_INITRAMFS && build_initramfs
$BUILD_RAMROOM   && build_ramroot
